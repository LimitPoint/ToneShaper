//
//  PiecewiseIntegrator.swift
//  ToneShaper
//
//  Created by Joseph Pagliaro on 8/22/23.
//

import Foundation
import Accelerate

class PiecewiseIntegrator {
    
    private var userIFCurve:[CGPoint]
    private var sampleCount: Int
    private var rangeCount: Int
    private var delta:Double
    
    private var partitions:[ClosedRange<Int>] = []
    private var scale:Double = 0
    private var userIFValues:[Double] = []
    
    private var currentPartition:ClosedRange<Int> = 0...0
    private var partialV:[Double] = []
    private var lastIntegral:[Double] = []
    
    var volume:Double = 1
    
    var currentIndex = -1
    
    /*
     sampleCount and delta are usually determined by the desired curve duration and the sample rate of the audio to be generated. 
     
     rangeCount defaults to 1024, and determines the number of partitions will be used for integration to control memory usage in the case of very long durations desired, and does not affect the sound of the audio to be generated.
     
     Example:
     
     let curveSampleCount = Int(curveDuration * Double(sampleRate))
     let stepSize = 1.0 / Double(sampleRate)
     
     let piecewise_integrator = PiecewiseIntegrator(userIFCurve: userIFCurve, sampleCount: curveSampleCount, delta: stepSize)
     
     Then commonly nextIntegral(n) is used to calculate `n` integrations for a sample range with n elements:
     
     let integral = piecewise_integrator.nextIntegral(n: sampleRange.count)
     
     See
     
     func audioSamplesForRange(piecewise_integrator:PiecewiseIntegrator, sampleRate:Int, sampleRange:ClosedRange<Int>) -> [Int16] 
     
     in PiecewiseIntegratorToneWriter.swift
     
     */
    init(userIFCurve:[CGPoint], sampleCount: Int, delta:Double, rangeCount: Int = 1024) {
        self.userIFCurve = userIFCurve
        self.sampleCount = sampleCount
        self.rangeCount = rangeCount
        self.delta = delta
        
        setup()
    }
    
    func setup() {
        currentIndex = -1
        
        partitions = PiecewiseIntegrator.createPartitionRanges(sampleCount: sampleCount, rangeCount: rangeCount)
        scale = PiecewiseIntegrator.scale(sampleCount: sampleCount, userIFCurve: userIFCurve)
        userIFValues = PiecewiseIntegrator.userIFValues_by_interpolateUserIFCurve(userIFCurve: userIFCurve)
        
        currentPartition = partitions[0]
        partialV = PiecewiseIntegrator.sampleIFValuesForRange(scale: scale, sampleRange: currentPartition, userIFValues: userIFValues)
        lastIntegral = PiecewiseIntegrator.integrate(samples: partialV, stepSize: delta)
    }
    
    class func integrate(samples:[Double], stepSize:Double, useSimpsons:Bool = false) -> [Double] {
        
        let sampleCount = samples.count
        var step = stepSize
        
        var result = [Double](repeating: 0.0, count: sampleCount)
        
        if useSimpsons {
            vDSP_vsimpsD(samples, 1, &step, &result, 1, vDSP_Length(sampleCount))
        }
        else {
            vDSP_vtrapzD(samples, 1, &step, &result, 1, vDSP_Length(sampleCount))
        }
        
        return result
    }
    
    class func scale(sampleCount:Int, userIFCurve:[CGPoint]) -> Double {
        Double(sampleCount-1) / userIFCurve.last!.x
    }
    
    class func createPartitionRanges(sampleCount: Int, rangeCount: Int) -> [ClosedRange<Int>] {
        
        guard rangeCount > 0 else {
            return []
        }
        
        var ranges: [ClosedRange<Int>] = []
        
        var start = 0
        while start < sampleCount {
            let end = min(start + rangeCount, sampleCount) - 1
            let range = start...end
            ranges.append(range)
            start = end + 1
        }
        
        return ranges
    }
    
    class func userIFValues_by_interpolateUserIFCurve(userIFCurve:[CGPoint]) -> [Double] {
        
        let indices = userIFCurve.map { Double($0.x) }
        let values = userIFCurve.map { Double($0.y) }
        
        return vDSP.linearInterpolate(values: values, atIndices: indices)
    }
    
    /*
     Originally:
     
     A user IF (instantaneous frequency) curve is going to be generated by a user drawing points in a view as a single value function of the x coordinate, or index. 
     
     The view coordinates will be increasing unique integer values, that may skip values, or not start at 0,
     
     ex:  5, 10, 11, 17 etc.
     
     generateRandomUserPoints generates an array of of CGPoint:
     
     arrayCount : desired count of the array
     maxIndex : the maximum possible value of the indices (like the view width)
     valueRange : the range of values for the y coordinate (like the view height range)
     
     Note that it must be that maxIndex >= arrayCount-1, to ensure it fills up
     
     In practice view coordinates are mapped from `width x height` to `duration x frequencyRange`, for document storage.
     
     */
    class func generateRandomUserPoints(count: Int, duration: Double, frequencyRange: ClosedRange<Double>) -> [CGPoint]? {
        
        guard count > 1 else {  // at least two points
            return nil
        }
        
        var randomXValues = Set<Double>()
        while randomXValues.count != count {
            let randomX = Double.random(in: 0...duration)
            randomXValues.insert(randomX)
        }
        
        var sortedXValues = randomXValues.sorted()
        
            // endpoints must match duration range
        sortedXValues[0] = 0
        sortedXValues[count-1] = duration
        
        let yValues = (0..<count).map { _ in
            CGFloat(Double.random(in: frequencyRange))
        }
        
        var points: [CGPoint] = []
        for i in 0..<count {
            points.append(CGPoint(x: CGFloat(sortedXValues[i]), y: yValues[i]))
        }
        
        return points
    }
    
    /*
     This function is not used in the implementation, but is useful for testing.
     */
    class func allSampleIFValues_by_interpolateUserIFCurve(sampleCount:Int, userIFCurve:[CGPoint]) -> ([Double], [Double]) {
        
        let userIFIndices = userIFCurve.map { Double($0.x) }
        let userIFValues = userIFCurve.map { Double($0.y) }
        
        let scale = scale(sampleCount: sampleCount, userIFCurve: userIFCurve)
        
        let sampleIFIndices = userIFIndices.map { ($0 * scale).rounded() }
        
        return (vDSP.linearInterpolate(values: userIFValues, atIndices: sampleIFIndices), sampleIFIndices)
    }
    
    /*
     Map userIFValues (user space) to sample range (audio sample space) using interploation. 
     
     Since sampleIndices range from sampleRange.lowerBound to sampleRange.upperBound that 
     
     result.count = sampleRange.count = upperBound - lowerBound + 1
     */
    class func sampleIFValuesForRange(scale:Double, sampleRange:ClosedRange<Int>, userIFValues:[Double]) -> [Double] {
            // scale sample range into user range
        let ta = Double(sampleRange.lowerBound) / scale 
        let tb = Double(sampleRange.upperBound) / scale 
        
        var valuesToInterpolate:[Double] = []
        var sampleIndices:[Double] = []
        
        func appendInterploatedValue(_ t:Double) {
            let delta = (t - t.rounded(.down))
            let index = Int(t.rounded(.down))
            if delta == 0 || (index+1 > userIFValues.count-1) { // index+1 may be out of bounds when delta = 0, or very nearly 0
                valuesToInterpolate.append(userIFValues[index])
            }
            else {
                let interpolated = userIFValues[index] * (1 - delta) + userIFValues[index+1] * delta
                valuesToInterpolate.append(interpolated)
            }
        }
        
        if ta == tb {
            appendInterploatedValue(ta) 
            sampleIndices.append(Double(sampleRange.lowerBound))
        }
        else {
            
                // start
            appendInterploatedValue(ta) 
            sampleIndices.append(Double(sampleRange.lowerBound))
            
                // middle, if any
            var lowerBound = Int(ta.rounded(.up))
            if lowerBound == Int(ta.rounded(.down)) {
                lowerBound += 1
            }
            var upperBound = Int(tb.rounded(.down))
            if upperBound == Int(tb.rounded(.up)) {
                upperBound -= 1
            }
            
            if lowerBound <= upperBound {
                valuesToInterpolate.append(contentsOf: Array(userIFValues[lowerBound...upperBound]))
                sampleIndices.append(contentsOf: (lowerBound...upperBound).map { Double($0) * scale })
            }
            
                // end
            appendInterploatedValue(tb) 
            sampleIndices.append(Double(sampleRange.upperBound))
            
        }
        
        sampleIndices = sampleIndices.map { $0 - sampleIndices[0]}
        
        return vDSP.linearInterpolate(values: valuesToInterpolate, atIndices: sampleIndices)
    }
    
    private func nextIntegral() -> [Double] {
        
        if currentIndex == self.partitions.count-1 {
            setup()
            return nextIntegral()
        }
        else {
            
            currentIndex += 1
            
            if currentIndex == 0 {
                return self.lastIntegral
            }
            else {
                currentPartition = partitions[currentIndex]
                partialV = [partialV.last!] + PiecewiseIntegrator.sampleIFValuesForRange(scale: scale, sampleRange: currentPartition, userIFValues: userIFValues)
                let lastIntegralValue = lastIntegral.last!
                lastIntegral = PiecewiseIntegrator.integrate(samples: partialV, stepSize: delta)
                lastIntegral.removeFirst()
                lastIntegral = vDSP.add(lastIntegralValue, lastIntegral)
                
                return self.lastIntegral
            }
        }
    }
    
    var buffer:[Double] = []
    
    func nextIntegral(n:Int) -> [Double] {
        
        var result = [Double]()
        
            // First, use elements from the buffer
        while result.count < n && !buffer.isEmpty {
            result.append(buffer.removeFirst())
        }
        
            // Call nextIntegral() until result has n elements
        while result.count < n {
            let elements = nextIntegral()
            let remainingSpace = n - result.count
            
            if elements.count <= remainingSpace {
                result.append(contentsOf: elements)
            } else {
                result.append(contentsOf: elements.prefix(remainingSpace))
                buffer = Array(elements.suffix(elements.count - remainingSpace))
            }
        }
        
        return result
    }
}
